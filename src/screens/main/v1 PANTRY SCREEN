import React, { useState, useEffect, useCallback, useRef } from 'react';
import {
    View,
    Text,
    FlatList,
    StyleSheet,
    SafeAreaView,
    ActivityIndicator,
    Alert,
    TouchableOpacity,
    TextInput,
    KeyboardAvoidingView,
    Platform,
    StatusBar,
    Button,
    Modal,
    RefreshControl,
    Linking,
    Animated,
    Easing,
    Pressable,
} from 'react-native';
import { useFocusEffect, useRoute } from '@react-navigation/native';
import { supabase } from '../services/supabaseClient';
import { COLORS, FONTS, SIZES } from '../constants';
import Icon from 'react-native-vector-icons/MaterialIcons';
import RNPickerSelect from 'react-native-picker-select';
import { CameraView, useCameraPermissions } from 'expo-camera';
import * as Haptics from 'expo-haptics';
import StockConfirmation from '../components/StockConfirmation';
import ManualAddSheet from '../components/ManualAddSheet';
import Ionicons from 'react-native-vector-icons/Ionicons';
import MaterialCommunityIcons from 'react-native-vector-icons/MaterialCommunityIcons';

// Helper to parse quantity for comparison or extraction
const parseQuantity = (quantity) => {
  if (typeof quantity === 'number') return quantity;
  if (typeof quantity !== 'string') return 1; // Default for non-strings
  const match = quantity.match(/^\d+(\.\d+)?/); // Match leading digits (including decimals)
  return match ? parseFloat(match[0]) : 1; // Default to 1 if no digits found, use parseFloat for decimals
};

// Helper to guess unit from quantity string
const getUnitFromString = (quantityString) => {
    const qLower = String(quantityString || '').toLowerCase();
    if (qLower.includes('ml') || qLower.includes('milliliter')) return 'ml';
    if (qLower.includes('l') || qLower.includes('liter')) return 'l';
    if (qLower.includes('kg') || qLower.includes('kilogram')) return 'kg';
    if (qLower.includes('g') || qLower.includes('gram')) return 'g';
    if (qLower.includes('oz') || qLower.includes('ounce')) return 'oz';
    if (qLower.includes('lb') || qLower.includes('pound')) return 'lbs';
    if (qLower.includes('cup')) return 'cups';
    // Add more common units as needed
    // Check if it's just a number (or could be parsed as one) - default to 'units'
    if (/^\d+(\.\d+)?$/.test(qLower.trim())) return 'units';
    // Default if no specific unit identified
    return 'units'; 
};

export default function MyStockScreen({ navigation }) {
    const [stockData, setStockData] = useState([]);
    const [isFetchingStock, setIsFetchingStock] = useState(false);
    const [isProcessing, setIsProcessing] = useState(false);
    const [error, setError] = useState(null);
    const [userId, setUserId] = useState(null);

    const [searchQuery, setSearchQuery] = useState('');
    const [filteredStockItems, setFilteredStockItems] = useState([]);
    const [refreshing, setRefreshing] = useState(false);
    const route = useRoute();

    // --- State for the Manual Add/Edit Sheet visibility and data ---
    const [isManualAddSheetVisible, setIsManualAddSheetVisible] = useState(false);
    const [editingItem, setEditingItem] = useState(null); // State to hold item being edited

    const unitOptions = [
        { label: 'Units', value: 'units' },
        { label: 'Grams', value: 'grams' },
        { label: 'Cups', value: 'cups' },
        { label: 'Milliliters', value: 'ml' },
        { label: 'Liters', value: 'l' },
        { label: 'Kilograms', value: 'kg' },
        { label: 'Ounces', value: 'oz' },
        { label: 'Pounds', value: 'lbs' }
    ]; 

    // --- Re-add Camera/Confirmation State --- 
    const [permission, requestPermission] = useCameraPermissions();
    const cameraRef = useRef(null);
    const [isCameraModalVisible, setIsCameraModalVisible] = useState(false);
    const [isAnalyzing, setIsAnalyzing] = useState(false);
    const [itemsForConfirmation, setItemsForConfirmation] = useState(null);

    // Add new state for animations
    const spinValue = useRef(new Animated.Value(0)).current;
    const [analysisMessage, setAnalysisMessage] = useState('Analyzing your pantry...');
    const analysisPhrases = [
        "Analyzing your pantry...",
        "Identifying items...",
        "Looking for ingredients...",
        "Processing labels...",
        "Almost done...",
        "AI is working its magic..."
    ];

    // Add new animated values for button animations
    const scanButtonScale = useRef(new Animated.Value(1)).current;
    const addButtonScale = useRef(new Animated.Value(1)).current;

    // Fetch User ID
    useEffect(() => {
        const getUser = async () => {
            const { data: { session } } = await supabase.auth.getSession();
            if (session?.user) {
                setUserId(session.user.id);
            } else {
                console.warn("MyStockScreen: No user session found. User might be logging out or not logged in.");
                setUserId(null); // Ensure userId is null if no session
                // Alert.alert("Error", "User session not found. Please log in again."); // Consider removing
                // navigation.navigate('Login'); // REMOVE THIS LINE
            }
        };
        getUser();
    }, []); // Dependency array changed, assuming navigation was only for the removed line.

    // Fetch Stock Data - MODIFIED to read from 'stock' table
    const fetchStock = useCallback(async (currentUserId) => {
        if (!currentUserId) {
            console.log("[MyStockScreen fetchStock] Aborting: No user ID.");
            return;
        }
        console.log(`[MyStockScreen fetchStock] Fetching stock for user: ${currentUserId}`);
        setIsFetchingStock(true);
        setError(null);
        try {
            const { data, error: fetchError } = await supabase
                .from('stock') 
                .select('item_name, quantity, unit, description') 
                .eq('user_id', currentUserId); 

            // --- LOG 1: Raw data from Supabase ---
            console.log("[MyStockScreen fetchStock] Raw data received:", JSON.stringify(data));

            if (fetchError) {
                throw fetchError;
            }
            
            let stockArray = data || [];

            // --- LOG 2: Array before potential sorting (if any) ---
            console.log("[MyStockScreen fetchStock] Stock array length before sort:", stockArray.length);

            // Sort the array alphabetically (assuming this part was kept/re-added)
            stockArray.sort((a, b) => 
              (a.item_name || '').toLowerCase().localeCompare((b.item_name || '').toLowerCase())
            );
            
            // --- LOG 3: Array after sorting ---
             console.log("[MyStockScreen fetchStock] Stock array length after sort:", stockArray.length);

            // --- LOG 4: Setting state ---
             console.log("[MyStockScreen fetchStock] Setting stock data state.");
            setStockData(stockArray);

        } catch (err) {
            // --- LOG 5: Error caught ---
            console.error("[MyStockScreen fetchStock] Error fetching stock:", err);
            setError("Failed to load stock data.");
            setStockData([]);
        } finally {
            // --- LOG 6: Fetch complete ---
             console.log("[MyStockScreen fetchStock] Fetch finished.");
            setIsFetchingStock(false);
        }
    }, [userId]); // Make sure userId is a dependency if needed

    // Refetch stock when screen focuses or userId changes
    useFocusEffect(
        useCallback(() => {
            // Define the async function inside the effect
            async function loadStock() {
                if (userId) {
                    await fetchStock(userId); // Call the existing fetchStock function
                }
            }
            // Call the async function
            loadStock();
            
            // Optional cleanup function (if needed)
            return () => {
                // console.log("[MyStockScreen useFocusEffect] Screen blurred or unmounted.");
            };
        }, [userId, fetchStock]) // Keep dependencies
    );

    // --- REVERTED handleConfirmItems with Fallback Error Handling ---
    const handleConfirmItems = async (items, callback) => {
        // Check if userId is available before proceeding
        if (!userId) {
            console.error('[MyStockScreen handleConfirmItems] Error: userId is not available.');
            Alert.alert("Error", "User session not found. Cannot save items.");
            return; // Stop execution if no user ID
        }
        
        setIsProcessing(true);
        console.log('[MyStockScreen handleConfirmItems] Callback received.');
        console.log('[MyStockScreen handleConfirmItems] isProcessing = true. Received items:', items);
        console.log('[MyStockScreen handleConfirmItems] Using authenticated userId:', userId); // Log the userId being used

        const preparedItems = items.map(item => ({
            user_id: userId, // Use the authenticated userId from state
            item_name: item.item_name,
            quantity: item.quantity,
            unit: item.unit,
            description: item.description || null
            // Assuming weight and created_at are handled by DB or not needed here
        }));
        console.log('[MyStockScreen handleConfirmItems] Items prepared for DB:', preparedItems);

        console.log('[MyStockScreen handleConfirmItems] Starting upsert...');
        try {
            const { error } = await supabase
                .from('stock')
                .upsert(preparedItems, { onConflict: ['user_id', 'item_name'] });

            console.log('[MyStockScreen handleConfirmItems] Upsert result:', { error }); // Log result

            if (error) {
                 console.error('[MyStockScreen handleConfirmItems] Error from Supabase upsert:', error);
                throw error; // Throw the error to be caught by the catch block
            }

            console.log('[MyStockScreen handleConfirmItems] Upsert successful. Refreshing stock...');
            await fetchStock(userId); // Refresh stock using the correct userId
            setIsProcessing(false); // Set processing to false *before* callback
            callback?.(); // Call the original callback if provided

        } catch (error) {
            console.error('[MyStockScreen handleConfirmItems] Error upserting stock in catch block:', error);
            setError(error.message || 'An unknown error occurred during saving.'); // Set error state
            setIsProcessing(false); // Ensure processing is stopped
            
            // --- Fallback added to prevent freezing --- 
            setTimeout(() => {
                // Check if still processing after 5 seconds (shouldn't be, but as a safety net)
                if (isProcessing) { 
                    console.warn('[MyStockScreen handleConfirmItems] [TIMEOUT FALLBACK] Forcing isProcessing to false after error...');
                    setIsProcessing(false);
                }
            }, 5000); // 5-second timeout as fallback
        }
        // No finally block needed as setIsProcessing is handled in try/catch
    };
    // --- END REVERTED handleConfirmItems ---

    // --- Render Stock Item for the List ---
    const renderFullStockItem = ({ item, index }) => {
        // --- LOG 7: Rendering item ---
        console.log(`[MyStockScreen renderFullStockItem START] Rendering item ${index}:`, JSON.stringify(item));
        
        // --- RESTORED ORIGINAL COMPLEX RENDER --- 
        try {
            return (
                <TouchableOpacity 
                    style={styles.stockItemContainer}
                    activeOpacity={0.7}
                    onPress={() => handleEditItem(item)}
                > 
                    {/* LOG 7a */ console.log(`[Item ${index}] Rendering Icon Container...`)}
                    <View style={styles.stockIconContainer}>
                        <Icon name="kitchen" size={18} color={COLORS.primary} />
                    </View>
                    
                    {/* LOG 7b */ console.log(`[Item ${index}] Rendering Content View...`)}
                    <View style={styles.stockItemContent}>
                       {/* LOG 7c */ console.log(`[Item ${index}] Rendering Name: ${item.item_name}`)}
                        <Text style={styles.stockItemName} numberOfLines={1}>
                            {(item.item_name || '').charAt(0).toUpperCase() + (item.item_name || '').slice(1)}
                        </Text>
                        
                        {/* LOG 7d */ console.log(`[Item ${index}] Rendering Details Row...`)}
                        <View style={[
                            styles.stockItemDetailsRow, 
                            { marginBottom: item.description ? 4 : 0 } 
                        ]}>
                            {/* LOG 7e */ console.log(`[Item ${index}] Rendering Quantity Chip... Quantity: ${item.quantity}, Unit: ${item.unit}`)}
                            <View style={styles.quantityChip}>
                                <Text style={styles.quantityChipText}>
                                    {item.quantity !== null && item.quantity !== undefined ? `${item.quantity} ${item.unit || ''}` : 'In Stock'}
                                </Text>
                            </View>
                            {/* <Text style={styles.stockItemDate}>Added recently</Text> */}
                        </View>
                        
                        {item.description && (
                             <> 
                               {/* LOG 7f */ console.log(`[Item ${index}] Rendering Description: ${item.description}`)}
                               <Text style={styles.stockItemDescription} numberOfLines={2}>{item.description}</Text>
                             </> 
                        )}
                    </View>
                    
                    {/* LOG 7g */ console.log(`[Item ${index}] Rendering Action Container...`)}
                    <View style={styles.itemActionContainer}>
                        <TouchableOpacity 
                            onPress={() => handleEditItem(item)} 
                            style={styles.actionIconTouch}
                        >
                            <Icon name="edit" size={20} color={COLORS.darkgray} />
                        </TouchableOpacity>
                        <TouchableOpacity 
                            onPress={() => handleDeleteItem(item)} 
                            style={styles.actionIconTouch}
                        >
                            <Icon name="delete-outline" size={22} color={COLORS.error} />
                        </TouchableOpacity>
                    </View>
                    {/* LOG 7h */ console.log(`[Item ${index}] Finished Rendering Item View.`)}
                </TouchableOpacity>
            );
        } catch (renderError) {
            console.error(`[MyStockScreen renderFullStockItem ERROR] Error rendering item ${index} (${item.item_name}):`, renderError);
            // Render a fallback UI for the item that failed
            return (
                 <View style={{ padding: 10, borderBottomWidth: 1, borderColor: 'red' }}>
                     <Text style={{ color: 'red' }}>Error rendering: {item.item_name || 'No Name'}</Text>
                 </View>
            );
        }
        // --- END ORIGINAL COMPLEX RENDER --- 
    };

    // For RNPickerSelect
    const pickerSelectStyles = StyleSheet.create({
        inputIOS: {
            fontSize: 16,
            paddingVertical: 14,
            paddingHorizontal: 18,
            borderWidth: 1,
            borderColor: 'rgba(0,0,0,0.08)',
            borderRadius: 12,
            color: COLORS.black,
            paddingRight: 40,
            backgroundColor: 'rgba(0,0,0,0.02)',
        },
        inputAndroid: {
            fontSize: 16,
            paddingHorizontal: 18,
            paddingVertical: 12,
            borderWidth: 1,
            borderColor: 'rgba(0,0,0,0.08)',
            borderRadius: 12,
            color: COLORS.black,
            paddingRight: 40,
            backgroundColor: 'rgba(0,0,0,0.02)',
        },
        placeholder: {
            color: 'rgba(0,0,0,0.4)',
            fontSize: 16,
        },
        iconContainer: {
            top: 14,
            right: 16,
        },
    });

    // --- Edit/Delete Item Handlers ---
    const handleEditItem = (item) => {
        console.log("Editing item:", item);
        setEditingItem(item); // Set the item to be edited
        setIsManualAddSheetVisible(true); // Open the sheet
    };

    const handleDeleteItem = (item) => {
        console.log("Deleting item:", item);
        Alert.alert(
            "Confirm Delete", 
            `Are you sure you want to delete ${item.item_name}?`, 
            [
                { text: "Cancel", style: "cancel" },
                { 
                    text: "Delete", 
                    onPress: async () => {
                        console.log("Confirmed delete for:", item.item_name);
                        setIsProcessing(true); // Show loading indicator
                        try {
                            const { error } = await supabase
                                .from('stock')
                                .delete()
                                .match({ user_id: userId, item_name: item.item_name }); // Match user and item name

                            if (error) {
                                throw error;
                            }
                            Alert.alert("Success", `Deleted ${item.item_name}.`);
                            await fetchStock(userId); // Refresh list
                        } catch (err) {
                            console.error("Error deleting item:", err);
                            Alert.alert("Error", `Failed to delete item: ${err.message}`);
                        } finally {
                            setIsProcessing(false);
                        }
                    }, 
                    style: "destructive" 
                }
            ]
        );
    };

    // Function to handle saving from the ManualAddSheet
    const handleSaveItemFromSheet = async (submittedItem) => {
        if (!userId) {
            Alert.alert("Error", "User session not found. Cannot save item.");
            return;
        }
        setIsManualAddSheetVisible(false); // Close the sheet first
        setIsProcessing(true); // Show processing indicator
        setError(null);
        console.log('[MyStockScreen handleSaveItem] Saving item:', submittedItem);

        try {
            // Removed: let result = null; // Results handled within blocks

            if (submittedItem.original_item_name) {
                // --- EDIT MODE --- (Logic remains the same for now)
                console.log(`[MyStockScreen handleSaveItem] Updating item from ${submittedItem.original_item_name} to ${submittedItem.item_name}`);
                const { error: updateError } = await supabase
                    .from('stock')
                    .update({ 
                        item_name: submittedItem.item_name, 
                        quantity: submittedItem.quantity, 
                        unit: submittedItem.unit,
                        // description: submittedItem.description // Add if description is included
                    })
                    .match({ user_id: userId, item_name: submittedItem.original_item_name }); 
                
                if (updateError) {
                    console.error('[MyStockScreen handleSaveItem] Supabase update error:', updateError);
                    throw updateError;
                }
                console.log('[MyStockScreen handleSaveItem] Item updated successfully.');

            } else {
                // --- ADD MODE --- (Handle duplicates/combining)
                console.log('[MyStockScreen handleSaveItem] ADD mode. Checking for existing item:', submittedItem.item_name);

                // 1. Check if item exists (Case-Insensitive)
                console.log(`[MyStockScreen handleSaveItem] Checking for existing item (case-insensitive): '${submittedItem.item_name}'`);
                const { data: existingData, error: selectError } = await supabase
                    .from('stock')
                    // Select the actual item_name along with quantity and unit
                    .select('item_name, quantity, unit') 
                    .eq('user_id', userId)
                    .ilike('item_name', submittedItem.item_name) 
                    .maybeSingle(); 

                if (selectError) {
                    console.error("[MyStockScreen handleSaveItem] Error checking for existing item:", selectError);
                    throw selectError; // Propagate error
                }

                if (existingData) {
                    // 2. Item Found - Store actual name
                    const actualItemName = existingData.item_name; // <-- Get the name as stored in DB
                    console.log(`[MyStockScreen handleSaveItem] Existing item found with name '${actualItemName}':`, existingData);
                    const existingQuantity = existingData.quantity;
                    const existingUnit = existingData.unit;
                    const newQuantity = submittedItem.quantity;
                    const newUnit = submittedItem.unit;

                    // 3. Compare Backend Units
                    if (existingUnit === newUnit) {
                        // 3a. Units Compatible - Combine Quantities
                        const totalQuantity = existingQuantity + newQuantity;
                        console.log(`[MyStockScreen handleSaveItem] Units match (${newUnit}). Combining quantities for '${actualItemName}': ${existingQuantity} + ${newQuantity} = ${totalQuantity}`);

                        const { error: combineError } = await supabase
                            .from('stock')
                            .update({ quantity: totalQuantity })
                             // Use the ACTUAL item name found in the database for matching
                            .match({ user_id: userId, item_name: actualItemName }); 

                        if (combineError) {
                            console.error("[MyStockScreen handleSaveItem] Error updating combined quantity:", combineError);
                            throw combineError;
                        }
                        console.log('[MyStockScreen handleSaveItem] Combined quantity updated successfully.');

                    } else {
                        // 3b. Units Incompatible - Alert User & Stop
                        console.warn(`[MyStockScreen handleSaveItem] Unit mismatch for item '${submittedItem.item_name}'. Existing: ${existingUnit}, New: ${newUnit}. Cannot combine.`);
                        Alert.alert(
                            "Cannot Add Item",
                            `'${submittedItem.item_name}' already exists in your stock with a different unit type (${existingUnit || 'N/A'}). Please edit the existing item or use a matching unit (${newUnit || 'N/A'}).`
                        );
                        // Important: Stop processing cleanly without throwing an error
                        setIsProcessing(false); // Turn off indicator
                        setEditingItem(null);   // Clear editing state just in case
                        return; // Exit the function here
                    }

                } else {
                    // 4. Item Not Found - Insert New
                    console.log('[MyStockScreen handleSaveItem] Item not found. Inserting new item:', submittedItem.item_name);
                    const { error: insertError } = await supabase
                        .from('stock')
                        .insert({
                            user_id: userId,
                            item_name: submittedItem.item_name,
                            quantity: submittedItem.quantity,
                            unit: submittedItem.unit,
                            // description: submittedItem.description // Add if description is included
                        });

                    if (insertError) {
                        console.error("[MyStockScreen handleSaveItem] Error inserting new item:", insertError);
                        // Optional: Check for unique constraint violation code if needed
                        // if (insertError.code === '23505') { ... }
                        throw insertError;
                    }
                    console.log('[MyStockScreen handleSaveItem] New item inserted successfully.');
                }
            }

            // --- Common Success Path for Add/Edit/Combine --- 
            console.log('[MyStockScreen handleSaveItem] Operation successful. Refreshing stock...');
            await fetchStock(userId); // Refresh stock list

        } catch (err) {
            // --- Error Handling --- (Keep existing block)
            console.error('[MyStockScreen handleSaveItem] Error saving item:', err);
            Alert.alert("Error", `Failed to save item: ${err.message}`);
            setError("Failed to save item.");
        } finally {
            // --- Cleanup --- (Keep existing block)
            setIsProcessing(false); // Hide indicator
            setEditingItem(null); // Clear editing state
        }
    };

    const handleCloseSheet = () => {
        setIsManualAddSheetVisible(false);
        setEditingItem(null); // Ensure editing state is cleared when sheet closes
    };

    // --- Re-add Camera Permission Check/Request Logic --- 
    const openCameraModal = async () => {
        console.log("[MyStockScreen openCameraModal] Attempting...");
        if (!permission) {
            await requestPermission(); // Request if status is unknown
            return; // Let user tap again after initial request
        }
        if (!permission.granted) {
            if (permission.canAskAgain) {
                const { status } = await requestPermission();
                if (status !== 'granted') {
                    Alert.alert('Permission Denied', 'Camera access is needed.');
                    return;
                }
            } else {
                // Cannot ask again, prompt to open settings
                 Alert.alert(
                    'Permission Required',
                    'Camera access was permanently denied. Please enable it in settings.',
                    [
                        { text: "Cancel", style: "cancel" },
                        { text: "Open Settings", onPress: () => Linking.openSettings() }
                    ]
                );
                return;
            }
        }
        // If permission granted, open modal
        console.log("[MyStockScreen openCameraModal] Permission granted, opening modal.");
        setIsCameraModalVisible(true);
    };

    // Start the spinning animation when isAnalyzing changes
    useEffect(() => {
        console.log('[MyStockScreen] isAnalyzing changed to:', isAnalyzing);
        if (isAnalyzing) {
            console.log('[MyStockScreen] Starting animations');
            // Start rotation animation
            startSpinAnimation();
            
            // Start cycling through messages
            const messageInterval = setInterval(() => {
                setAnalysisMessage(prev => {
                    const currentIndex = analysisPhrases.indexOf(prev);
                    const nextIndex = (currentIndex + 1) % analysisPhrases.length;
                    const newMessage = analysisPhrases[nextIndex];
                    console.log('[MyStockScreen] Changing message to:', newMessage);
                    return newMessage;
                });
            }, 2000); // Change message every 2 seconds
            
            return () => {
                console.log('[MyStockScreen] Clearing message interval');
                clearInterval(messageInterval);
            };
        }
    }, [isAnalyzing]);

    // Function to start spin animation
    const startSpinAnimation = () => {
        spinValue.setValue(0);
        Animated.loop(
            Animated.timing(spinValue, {
                toValue: 1,
                duration: 2000,
                easing: Easing.linear,
                useNativeDriver: true,
            })
        ).start();
    };

    // Create the spin interpolation
    const spin = spinValue.interpolate({
        inputRange: [0, 1],
        outputRange: ['0deg', '360deg']
    });

    // Update camera capture with minimum display time
    const handleCameraCapture = async () => {
        if (!cameraRef.current || isAnalyzing) return;

        setIsAnalyzing(true);
        console.log('[MyStockScreen] ANALYSIS STARTED - Setting isAnalyzing to true');
        Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
        console.log('[MyStockScreen] Taking picture...');

        try {
            const photo = await cameraRef.current.takePictureAsync({
                quality: 0.7,
                base64: true,
            });
            console.log('[MyStockScreen] Picture taken, calling function...');
            
            // Create a timestamp to ensure minimum analysis display time
            const analysisStartTime = new Date().getTime();
            console.log('[MyStockScreen] Analysis start time:', analysisStartTime);

            const { data, error: functionError } = await supabase.functions.invoke('recognize-stock', {
              body: { image: photo.base64 },
            });

            // Calculate elapsed time and force minimum display duration if needed
            const elapsedTime = new Date().getTime() - analysisStartTime;
            const minimumDisplayTime = 4000; // 4 seconds minimum to see the animation
            
            console.log('[MyStockScreen] Analysis completed in', elapsedTime, 'ms');
            
            if (elapsedTime < minimumDisplayTime) {
                console.log(`[MyStockScreen] Forcing animation to display for ${minimumDisplayTime - elapsedTime}ms more`);
                await new Promise(resolve => setTimeout(resolve, minimumDisplayTime - elapsedTime));
            }

            if (functionError) throw functionError;
            if (!data || !data.items || !Array.isArray(data.items)) {
                throw new Error('Invalid data format from recognition service.');
            }

            console.log('[MyStockScreen] Items recognized:', data.items);
            
            if (data.items.length === 0) {
                setIsAnalyzing(false);
                console.log('[MyStockScreen] No items recognized, setting isAnalyzing to false');
                Alert.alert('No Items Recognized', 'Could not detect items. Try a different angle or better lighting?');
                // Keep modal open for retry
            } else {
                console.log('[MyStockScreen] Setting items for confirmation');
                setItemsForConfirmation(data.items);
                setIsAnalyzing(false);
                console.log('[MyStockScreen] Setting isAnalyzing to false');
                setIsCameraModalVisible(false); // Close camera AFTER analyzing is false
            }
        } catch (error) {
            console.error('[MyStockScreen] Capture/Analysis Error:', error);
            setIsAnalyzing(false);
            console.log('[MyStockScreen] Error occurred, setting isAnalyzing to false');
            Alert.alert('Error', `Failed to process image: ${error.message}`);
            setIsCameraModalVisible(false); // Close modal on error
        }
    };

    // --- Confirmation Handlers --- 
    // Add handleCancelConfirmation
    const handleCancelConfirmation = () => {
        console.log('[MyStockScreen] Confirmation cancelled');
        setItemsForConfirmation(null); // Just hide the confirmation modal
    };

    // --- Update renderHeader to call openCameraModal --- 
    const renderHeader = () => (
        <View style={styles.headerContainer}>
            <View style={styles.searchContainer}>
                <Icon name="search" size={20} color={COLORS.gray} style={styles.searchIcon} />
                <TextInput
                    style={styles.searchInput}
                    placeholder="Search your stock..."
                    placeholderTextColor={COLORS.gray}
                    value={searchQuery}
                    onChangeText={setSearchQuery}
                />
            </View>
            <Text style={styles.photoTipsText}>
                <Text style={{ fontWeight: 'bold' }}>Photo Tips:</Text> Use good lighting & clear views for best results.
            </Text>
            <View style={styles.actionButtonsContainer}>
                 <TouchableOpacity 
                    style={styles.actionButton} 
                    onPress={openCameraModal}
                    disabled={isProcessing} 
                 >
                    <Ionicons name="camera-outline" size={24} color={COLORS.primary} />
                    <Text style={styles.actionButtonText}>Scan with Camera</Text>
                 </TouchableOpacity>
                 <TouchableOpacity 
                    style={styles.actionButton} 
                    onPress={() => { setEditingItem(null); setIsManualAddSheetVisible(true); }}
                    disabled={isProcessing}
                 >
                    <Ionicons name="add-circle-outline" size={24} color={COLORS.primary} />
                    <Text style={styles.actionButtonText}>Add Manually</Text>
                 </TouchableOpacity>
             </View>
        </View>
    );

    // Animation functions for buttons
    const animateButtonPress = (animatedValue, toValue) => {
        Animated.spring(animatedValue, {
            toValue,
            useNativeDriver: true,
            friction: 7,
            tension: 40
        }).start();
    };

    // --- Main Render ---
    return (
        <SafeAreaView style={styles.safeArea}>
            <StatusBar barStyle="light-content" backgroundColor={COLORS.primary} />
            <KeyboardAvoidingView 
                behavior={Platform.OS === "ios" ? "padding" : "height"} 
                style={{ flex: 1 }}
            >
                <View style={styles.container}>
                    <View style={styles.headerContainer}>
                        <Text style={styles.headerTitle}>My Pantry</Text>
                        <TouchableOpacity style={styles.headerButton}>
                            <Icon name="add" size={26} color={COLORS.primary} />
                        </TouchableOpacity>
                    </View>

                    <View style={styles.contentContainer}>
                        <View style={styles.sectionHeader}>
                            <Icon name="kitchen" size={22} color={COLORS.primary} />
                            <Text style={styles.sectionTitle}>Current Ingredients</Text>
                        </View>
                        
                        {/* Action Buttons Container with animations */}
                        <View style={styles.actionButtonsContainer}>
                            <Pressable
                                style={[styles.actionButton, styles.scanButton]}
                                onPress={openCameraModal}
                                disabled={isProcessing} 
                                onPressIn={() => animateButtonPress(scanButtonScale, 0.95)}
                                onPressOut={() => animateButtonPress(scanButtonScale, 1)}
                            >
                                <Animated.View style={{
                                    flexDirection: 'row', 
                                    alignItems: 'center',
                                    justifyContent: 'center',
                                    transform: [{ scale: scanButtonScale }]
                                }}>
                                    <Icon name="photo-camera" size={20} color={COLORS.primary} />
                                    <Text style={styles.actionButtonText}>Scan Pantry</Text>
                                </Animated.View>
                            </Pressable>

                            <Pressable
                                style={[styles.actionButton, styles.manualButton]}
                                onPress={() => setIsManualAddSheetVisible(true)} // Call triggerManualAdd
                                disabled={isProcessing} // Keep disabled state if needed
                                onPressIn={() => animateButtonPress(addButtonScale, 0.95)}
                                onPressOut={() => animateButtonPress(addButtonScale, 1)}
                            >
                                <Animated.View style={{
                                    flexDirection: 'row', 
                                    alignItems: 'center',
                                    justifyContent: 'center',
                                    transform: [{ scale: addButtonScale }]
                                }}>
                                    <Icon name="add" size={20} color={COLORS.white} />
                                    <Text style={[styles.actionButtonText, styles.manualButtonText]}>Add Manually</Text>
                                </Animated.View>
                            </Pressable>
                        </View>
                        {/* END NEW Action Buttons Container */}

                        {/* Add a wrapper View with flex: 1 around the conditional block */}
                        <View style={{ flex: 1 }}> 
                            {(() => {
                                // --- LOG 8: Checking render conditions ---
                                console.log(`[MyStockScreen Render Check] isLoadingStock: ${isFetchingStock}, error: ${error}, stockData.length: ${stockData.length}`);
                                
                                if (isFetchingStock && !stockData.length) {
                                     console.log("[MyStockScreen Render Check] Showing loading indicator.");
                                    return <ActivityIndicator size="large" color={COLORS.primary} style={styles.loader} />;
                                } else if (error) {
                                     console.log("[MyStockScreen Render Check] Showing error message.");
                                    return (
                                        <View style={styles.emptyStateContainer}> 
                                            <Icon name="error-outline" size={48} color="#e74c3c" />
                                            <Text style={styles.errorTitle}>Something went wrong</Text>
                                            <Text style={styles.errorText}>{error}</Text>
                                            <TouchableOpacity 
                                                style={styles.retryButton}
                                                onPress={() => fetchStock(userId)}
                                            >
                                                <Text style={styles.retryButtonText}>Try Again</Text>
                                            </TouchableOpacity>
                                        </View>
                                    );
                                } else if (stockData.length === 0) {
                                     console.log("[MyStockScreen Render Check] Showing empty state.");
                                    return (
                                        <View style={styles.emptyStateContainer}>
                                            <Icon name="shopping-basket" size={48} color={COLORS.primary} />
                                            <Text style={styles.emptyStateTitle}>Your pantry is empty</Text>
                                            <Text style={styles.emptyStateText}>Add ingredients by uploading an image or manually entering them below</Text>
                                        </View>
                                    );
                                } else {
                                    console.log("[MyStockScreen Render Check] Showing FlatList.");
                                    return (
                                        <FlatList
                                            data={stockData}
                                            renderItem={renderFullStockItem}
                                            keyExtractor={(item) => item.item_name} // Ensure item_name is unique per user
                                            style={styles.list}
                                            contentContainerStyle={styles.listContentContainer}
                                            showsVerticalScrollIndicator={false}
                                        />
                                    );
                                }
                            })()}
                        </View> 
                        {/* End wrapper View */}
                    </View>

                    {/* --- Manual Add/Edit Sheet --- */}
                    <ManualAddSheet 
                        isVisible={isManualAddSheetVisible}
                        onClose={handleCloseSheet} // Use dedicated close handler
                        onSubmit={handleSaveItemFromSheet} // Use the combined save handler
                        mode={editingItem ? 'edit' : 'add'} // Pass the mode
                        initialItemData={editingItem} // Pass item data for editing
                        unitOptions={unitOptions}
                    />
                </View>
            </KeyboardAvoidingView>

            {/* Re-add Camera Modal */}
            <Modal
                visible={isCameraModalVisible}
                animationType="slide"
                transparent={false}
                onRequestClose={() => !isAnalyzing && setIsCameraModalVisible(false)}
            >
                <SafeAreaView style={styles.cameraSafeArea}>
                   {permission?.granted ? (
                        <CameraView
                            ref={cameraRef}
                            style={styles.cameraPreview}
                            facing={'back'}
                        >
                           {/* Instructions */}
                           <Text style={styles.cameraInstructions}>
                               Position your pantry items clearly in the frame.
                           </Text>
                           
                           {/* Buttons Container */}
                           <View style={styles.cameraButtonsContainer}>
                               {!isAnalyzing && (
                                   <TouchableOpacity style={styles.captureButton} onPress={handleCameraCapture}>
                                        {/* Use appropriate icon */}
                                       <Ionicons name="radio-button-on" size={80} color="white" />
                                   </TouchableOpacity>
                               )}
                               <TouchableOpacity
                                   style={[styles.closeButton, isAnalyzing && styles.disabledButton]}
                                   onPress={() => setIsCameraModalVisible(false)}
                                   disabled={isAnalyzing}
                               >
                                   <Ionicons name="close-circle" size={40} color="white" />
                               </TouchableOpacity>
                           </View>
                           
                           {/* Enhanced Analysis Overlay */}
                           {isAnalyzing && (
                               <View style={styles.analysisOverlay} pointerEvents="none">
                                   <View style={styles.analysisContainer}>
                                       <Animated.View style={{ transform: [{ rotate: spin }] }}>
                                           <MaterialCommunityIcons name="food-fork-drink" size={60} color={COLORS.white} />
                                       </Animated.View>
                                       
                                       <Text style={styles.analysisTitle}>
                                           Analyzing Photo
                                       </Text>
                                       
                                       <Text style={styles.analysisText}>
                                           {analysisMessage}
                                       </Text>
                                       
                                       <View style={styles.progressDots}>
                                           <View style={[styles.progressDot, styles.progressDotActive]} />
                                           <View style={[styles.progressDot, isAnalyzing && analysisPhrases.indexOf(analysisMessage) >= 1 ? styles.progressDotActive : null]} />
                                           <View style={[styles.progressDot, isAnalyzing && analysisPhrases.indexOf(analysisMessage) >= 3 ? styles.progressDotActive : null]} />
                                       </View>
                                   </View>
                               </View>
                           )}
                       </CameraView>
                    ) : (
                        // Optional: Render permission request view inside modal if needed
                        <View style={styles.permissionDeniedViewModal}>
                            <Text style={styles.permissionText}>Camera permission is required.</Text>
                            {/* Add buttons to request/open settings if desired */}
                            <Button title="Close" onPress={() => setIsCameraModalVisible(false)} />
                        </View>
                    )}
                </SafeAreaView>
            </Modal>

            {/* Re-add Confirmation Modal render */}
            {itemsForConfirmation && (
                <StockConfirmation
                    isVisible={!!itemsForConfirmation}
                    items={itemsForConfirmation}
                    onConfirm={handleConfirmItems} // Use existing save handler
                    onCancel={handleCancelConfirmation} // Use new cancel handler
                    isProcessing={isProcessing} // Use existing processing state for DB save
                />
            )}
        </SafeAreaView>
    );
}

const styles = StyleSheet.create({
    safeArea: {
        flex: 1,
        backgroundColor: COLORS.primary,
    },
    container: {
        flex: 1,
        backgroundColor: '#f8f9fa',
    },
    headerContainer: {
        backgroundColor: COLORS.primary,
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'space-between',
        paddingHorizontal: SIZES.large,
        paddingVertical: SIZES.medium,
        borderTopWidth: 3,
        borderTopColor: COLORS.primaryDark,
        shadowColor: COLORS.black,
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.1,
        shadowRadius: 4,
        elevation: 3,
    },
    headerTitle: {
        fontSize: SIZES.h3,
        fontFamily: FONTS.family.bold,
        color: '#FFF',
    },
    headerButton: {
        padding: SIZES.base,
        backgroundColor: 'rgba(255,255,255,0.2)',
        borderRadius: SIZES.radius * 3,
        height: 36,
        width: 36,
        alignItems: 'center',
        justifyContent: 'center',
    },
    contentContainer: {
        flex: 1,
        padding: SIZES.large,
        backgroundColor: COLORS.background,
        // backgroundColor: 'lightblue', // REMOVE Temporary Background
    },
    uploadButtonContainer: {
        // Removed - Replaced by actionButtonsContainer
    },
    uploadButton: {
        // Removed - Replaced by actionButton styles
    },
    uploadButtonText: {
       // Removed - Replaced by actionButtonText styles
    },
    sectionHeader: {
        flexDirection: 'row',
        alignItems: 'center',
        marginBottom: SIZES.medium,
        backgroundColor: 'rgba(76, 175, 80, 0.08)',
        padding: SIZES.base,
        borderRadius: SIZES.radius,
        borderLeftWidth: 3,
        borderLeftColor: COLORS.primary,
    },
    sectionTitle: {
        fontSize: SIZES.h4,
        fontFamily: FONTS.family.semibold,
        color: COLORS.text,
        marginLeft: 8,
    },
    loader: {
        marginTop: 50,
    },
    list: {
        flex: 1,
        // backgroundColor: 'red', // REMOVE Temporary Background
        borderRadius: 16, 
        overflow: 'hidden', 
        marginTop: SIZES.base, 
    },
    listContentContainer: {
        paddingBottom: 20, // Padding at the end
    },
    stockItemContainer: {
        flexDirection: 'row',
        alignItems: 'center',
        paddingVertical: SIZES.radius,
        paddingHorizontal: SIZES.medium,
        backgroundColor: COLORS.surface, 
        borderRadius: SIZES.radius,
        marginVertical: SIZES.base / 2,
        marginHorizontal: SIZES.base,
        shadowColor: COLORS.black,
        shadowOffset: { width: 0, height: 1 },
        shadowOpacity: 0.08,
        shadowRadius: 2,
        elevation: 1,
    },
    stockIconContainer: {
        width: 40,
        height: 40,
        borderRadius: 20,
        backgroundColor: 'rgba(76, 175, 80, 0.15)',
        borderWidth: 1,
        borderColor: 'rgba(76, 175, 80, 0.2)',
        alignItems: 'center',
        justifyContent: 'center',
        marginRight: 14,
    },
    stockItemContent: {
        flex: 1,
    },
    stockItemName: {
        fontSize: SIZES.body2,
        fontFamily: FONTS.family.semibold,
        color: COLORS.text,
        marginBottom: 4,
    },
    stockItemDetailsRow: {
        flexDirection: 'row',
        alignItems: 'center',
    },
    quantityChip: {
        backgroundColor: 'rgba(76, 175, 80, 0.15)',
        paddingHorizontal: 8,
        paddingVertical: 4,
        borderRadius: 12,
        marginRight: 8,
    },
    quantityChipText: {
        fontSize: 12,
        fontFamily: FONTS.family.medium,
        color: COLORS.primary,
    },
    stockItemDate: { // Style for potential date display
        fontSize: 12,
        color: 'rgba(0,0,0,0.5)',
    },
    stockItemDescription: {
        fontSize: SIZES.body4,
        fontFamily: FONTS.family.regular,
        color: COLORS.textSecondary,
        marginTop: 4, // Add margin if description is shown
    },
    itemActionContainer: {
        flexDirection: 'row',
        alignItems: 'center',
        marginLeft: SIZES.base, // Space between content and actions
    },
    actionIconTouch: {
        padding: SIZES.base * 1.2, // Increase touchable area
        backgroundColor: 'rgba(0,0,0,0.03)',
        borderRadius: SIZES.radius * 2,
        marginLeft: SIZES.small, // Space between icons
    },
    deleteButton: {
        padding: 6,
    },
    emptyStateContainer: {
        alignItems: 'center',
        justifyContent: 'center',
        backgroundColor: 'rgba(76, 175, 80, 0.05)',
        borderRadius: SIZES.radius * 2,
        padding: SIZES.padding * 2,
        marginTop: SIZES.padding,
        marginHorizontal: SIZES.base,
        flex: 1,
        borderWidth: 1,
        borderColor: 'rgba(76, 175, 80, 0.1)',
        shadowColor: COLORS.black,
        shadowOffset: { width: 0, height: 1 },
        shadowOpacity: 0.1,
        shadowRadius: 4,
    },
    emptyStateTitle: {
        fontSize: SIZES.h3,
        fontFamily: FONTS.family.bold,
        color: COLORS.primary,
        marginTop: SIZES.medium,
        marginBottom: SIZES.base,
    },
    emptyStateText: {
        fontSize: SIZES.body3,
        fontFamily: FONTS.family.regular,
        color: 'rgba(0,0,0,0.5)',
        textAlign: 'center',
        lineHeight: SIZES.body3 * 1.5,
        maxWidth: '90%',
    },
    errorTitle: {
        fontSize: SIZES.h3,
        fontFamily: FONTS.family.bold,
        color: '#e74c3c',
        marginTop: SIZES.medium,
        marginBottom: SIZES.base,
    },
    errorText: {
        color: '#e74c3c',
        textAlign: 'center',
        marginBottom: SIZES.large,
        fontSize: SIZES.body3,
        fontFamily: FONTS.family.regular,
        maxWidth: '90%',
    },
    retryButton: {
        backgroundColor: '#e74c3c',
        paddingVertical: SIZES.radius,
        paddingHorizontal: SIZES.padding,
        borderRadius: SIZES.radius * 2,
        marginTop: SIZES.medium,
        shadowColor: '#e74c3c',
        shadowOffset: { width: 0, height: 1 },
        shadowOpacity: 0.2,
        shadowRadius: 2,
        elevation: 2,
    },
    retryButtonText: {
        color: '#FFF',
        fontFamily: FONTS.family.semibold,
        fontSize: SIZES.body3,
    },
    mockButton: {
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'center',
        alignSelf: 'center',
        paddingVertical: 12,
        paddingHorizontal: 20,
        backgroundColor: COLORS.primary,
        borderRadius: 20,
        marginTop: 15,
        shadowColor: COLORS.primary,
        shadowOffset: {
            width: 0,
            height: 2,
        },
        shadowOpacity: 0.15,
        shadowRadius: 4,
        elevation: 3,
    },
    mockButtonText: {
        fontSize: 14,
        color: '#FFF',
        fontWeight: '600',
        marginLeft: 8,
    },
    modalView: {
        flex: 1,
        justifyContent: 'center',
        alignItems: 'center',
        backgroundColor: 'rgba(0,0,0,0.8)',
    },
    camera: {
        width: '100%',
        height: '100%',
    },
    cameraOverlay: {
        flex: 1,
        backgroundColor: 'transparent',
        justifyContent: 'space-between',
        padding: 30,
        paddingTop: Platform.OS === 'ios' ? 60 : 30,
    },
    cameraButton: {
        alignSelf: 'center',
        padding: 10,
        borderRadius: 50,
        backgroundColor: 'rgba(0, 0, 0, 0.4)',
    },
    closeButton: {
        alignSelf: 'flex-start',
    },
    captureButton: {
        alignSelf: 'center',
        marginBottom: 20,
        width: 70,
        height: 70,
        borderRadius: 35,
        backgroundColor: COLORS.white,
        justifyContent: 'center',
        alignItems: 'center',
        borderWidth: 3,
        borderColor: COLORS.primary,
    },
    analyzingOverlay: {
        position: 'absolute',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: 'rgba(0, 0, 0, 0.6)',
        justifyContent: 'center',
        alignItems: 'center',
    },
    analyzingText: {
        color: COLORS.white,
        ...FONTS.h3,
        marginTop: SIZES.medium,
    },
    disabledButton: {
        opacity: 0.5,
    },
    permissionDeniedView: {
        flex: 1,
        justifyContent: 'center',
        alignItems: 'center',
        padding: SIZES.large,
        backgroundColor: COLORS.white,
        width: '90%',
        borderRadius: SIZES.medium,
        alignSelf: 'center',
    },
    permissionText: {
        ...FONTS.body3,
        textAlign: 'center',
        marginBottom: SIZES.large,
    },
    requestPermissionButton: {
        backgroundColor: COLORS.primary,
        paddingVertical: SIZES.small,
        paddingHorizontal: SIZES.large,
        borderRadius: SIZES.radius,
        marginBottom: SIZES.medium,
    },
    buttonText: {
        color: COLORS.white,
        ...FONTS.h4,
    },
    listContainer: {
        paddingBottom: 140,
        paddingHorizontal: SIZES.medium,
    },
    itemContainer: {
        backgroundColor: COLORS.white,
        padding: SIZES.medium,
        marginVertical: SIZES.base,
        borderRadius: SIZES.small,
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'center',
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 1 },
        shadowOpacity: 0.1,
        shadowRadius: 2,
        elevation: 2,
    },
    itemTextContainer: {
        flex: 1,
        marginRight: SIZES.small,
    },
    itemName: {
        ...FONTS.h4,
        color: COLORS.black,
        fontWeight: 'bold',
        marginBottom: 3,
    },
    itemQuantity: {
        ...FONTS.body4,
        color: COLORS.darkgray,
    },
    itemActions: {
        flexDirection: 'row',
        alignItems: 'center',
    },
    quantityInput: {
        borderWidth: 1,
        borderColor: COLORS.gray2,
        borderRadius: SIZES.small,
        paddingHorizontal: SIZES.small,
        paddingVertical: 2,
        width: 60,
        textAlign: 'center',
        marginHorizontal: SIZES.small,
        fontSize: SIZES.body4,
    },
    actionButton: {
        flex: 1, // Each button takes half the space
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'center',
        paddingVertical: SIZES.radius * 1.5,
        borderRadius: SIZES.radius * 1.5, // Slightly more rounded
        shadowColor: "#000",
        shadowOffset: { width: 0, height: 1 },
        shadowOpacity: 0.1,
        shadowRadius: 3,
        elevation: 2,
    },
    scanButton: {
        backgroundColor: 'rgba(76, 175, 80, 0.08)',
        marginRight: SIZES.base, // Space between buttons
        borderWidth: 1,
        borderColor: 'rgba(76, 175, 80, 0.3)',
        overflow: 'hidden',
    },
    manualButton: {
        backgroundColor: COLORS.primary,
        marginLeft: SIZES.base, // Space between buttons
        overflow: 'hidden',
    },
    actionButtonText: {
        marginLeft: SIZES.base,
        fontSize: SIZES.body4,
        fontFamily: FONTS.family.semibold,
    },
    scanButtonText: { // Specific style if needed, else inherits actionButtonText
        color: COLORS.primary,
    },
    manualButtonText: {
        color: COLORS.white,
    },
    manualAddButton: { // REMOVED bottom button style
       // Styles removed
    },
    manualAddButtonText: { // REMOVED bottom button text style
       // Styles removed
    },
    fab: {
        position: 'absolute',
        width: 60,
        height: 60,
        alignItems: 'center',
        justifyContent: 'center',
        right: 30,
        bottom: 30,
        backgroundColor: COLORS.primary,
        borderRadius: 30,
        elevation: 8,
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.3,
        shadowRadius: 4,
        zIndex: 2,
    },
    actionButtonsContainer: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        marginHorizontal: SIZES.base,
        marginBottom: SIZES.medium,
    },
    searchContainer: {
        flexDirection: 'row',
        alignItems: 'center',
        backgroundColor: 'rgba(0,0,0,0.08)',
        borderRadius: 12,
        paddingHorizontal: 12,
        paddingVertical: 4,
    },
    searchIcon: {
        marginRight: 8,
    },
    searchInput: {
        flex: 1,
        color: COLORS.black,
    },
    photoTipsText: {
        ...FONTS.body3,
        color: 'rgba(0,0,0,0.5)',
        marginBottom: SIZES.medium,
    },
    cameraSafeArea: { 
        flex: 1, 
        backgroundColor: 'black' 
    },
    cameraPreview: {
        flex: 1,
    },
    cameraButtonsContainer: {
        position: 'absolute',
        bottom: 0,
        left: 0,
        right: 0,
        height: 120, 
        backgroundColor: 'rgba(0,0,0,0.4)', 
        flexDirection: 'row',
        justifyContent: 'center', 
        alignItems: 'center',
    },
    analysisOverlay: {
        position: 'absolute',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: 'rgba(0,0,0,0.85)',
        justifyContent: 'center',
        alignItems: 'center',
        zIndex: 10,
    },
    analysisContainer: {
        padding: SIZES.padding * 2,
        borderRadius: SIZES.radius,
        backgroundColor: 'rgba(0,0,0,0.5)',
        alignItems: 'center',
        width: '80%',
        maxWidth: 350,
    },
    analysisTitle: {
        color: COLORS.white,
        marginTop: SIZES.radius * 2,
        marginBottom: SIZES.radius,
        ...FONTS.h2,
        textAlign: 'center',
    },
    analysisText: {
        color: COLORS.white,
        marginTop: SIZES.base,
        ...FONTS.body3,
        textAlign: 'center',
        opacity: 0.9,
    },
    progressDots: {
        flexDirection: 'row',
        marginTop: SIZES.padding * 1.5,
        justifyContent: 'center',
    },
    progressDot: {
        width: 10,
        height: 10,
        borderRadius: 5,
        backgroundColor: 'rgba(255,255,255,0.3)',
        marginHorizontal: 5,
    },
    progressDotActive: {
        backgroundColor: COLORS.primary || COLORS.white,
    },
    cameraInstructions: {
        color: COLORS.white,
        textAlign: 'center',
        backgroundColor: 'rgba(0,0,0,0.5)',
        padding: SIZES.base,
        marginTop: SIZES.padding * 2 + (Platform.OS === 'ios' ? 20 : 0),
        marginHorizontal: SIZES.padding,
        borderRadius: SIZES.radius,
        ...FONTS.body4,
        position: 'absolute',
        top: 0,
        left: 10,
        right: 10,
        zIndex: 5,
    },
    permissionDeniedViewModal: {
         flex: 1,
         justifyContent: 'center',
         alignItems: 'center',
         backgroundColor: 'black',
         padding: SIZES.padding,
    },
}); 